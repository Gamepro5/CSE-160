module RoutingP
{
    provides interface Routing;
    uses interface NeighborDiscovery;
    uses interface Flooding;

    uses interface Timer<TMilli> as waitTimer;
}

implementation
{
    Neighbor neighborTable[MAX_NEIGHBOR];
    Route table[MAX_ROUTING];
    TableCache cache[TABLE_CACHE_SIZE];
    uint8_t tablePointer = 0;
    uint8_t cachePointer = 0;
    bool initialized = FALSE;

    pack sendPackage;
    uint8_t i;


    command void Routing.init()
    {
        Route update;
        update.dest = TOS_NODE_ID;
        update.to = 0;
        update.cost = 0;
        update.toAlt = 0;
        update.costAlt = INFINITY;
        table[tablePointer++] = update;
        if(tablePointer >= MAX_ROUTING) tablePointer = 0;

        update.dest = 0;
        for(i = 1; i < MAX_ROUTING; i++)
        {
            table[i] = update;
        }

        call waitTimer.startOneShot(15000);
    }

    event void waitTimer.fired()
    {
        if(initialized == FALSE)
        {
            for(i = 0; i < MAX_NEIGHBOR; i++)
            {
                if(neighborTable[i].address != 0)
                {
                    Route update;
                    update.dest = neighborTable[i].address;
                    update.to = neighborTable[i].address;
                    update.cost = 1;
                    update.toAlt = 0;
                    update.costAlt = INFINITY;
                    table[tablePointer++] = update;
                }
                if(tablePointer >= MAX_ROUTING) tablePointer = 0;
            }
            initialized = TRUE;
        }
        call Routing.floodLinkState();
        call waitTimer.startOneShot(15000);
    }

    event void NeighborDiscovery.updateNeighbors(void* data, uint8_t len)
    {
        memcpy(neighborTable, data, len);
    }

    command void Routing.floodLinkState()
    {
        // // Reused space for sending parsed payload across multiple packets
        uint8_t payload[FLOODING_MAX_PAYLOAD_SIZE];
        LSA* data = &payload;
        
        data->cost = 0;
        
        // // Parse and send the data
        // for(i = 0; i < sizeof(Route)*MAX_ROUTING - FLOODING_MAX_PAYLOAD_SIZE; i = i + FLOODING_MAX_PAYLOAD_SIZE)
        // {
        //     memcpy(&payload, &table + i, FLOODING_MAX_PAYLOAD_SIZE);
        //     call Flooding.startFlood(AM_BROADCAST_ADDR, &payload, PROTOCOL_LINK_STATE);
        // }
        // memcpy(&payload, &table + i, sizeof(Route)*MAX_ROUTING - i);
        call Flooding.startFlood(AM_BROADCAST_ADDR, &payload, PROTOCOL_LINK_STATE);
    }
    
    command void Routing.receivedLinkStatePacket(pack* myMsg)
    {
        floodingheader* header = (floodingheader*)&(myMsg->payload);
        LSA* data = header->payload;
        bool found = FALSE;
        bool updated = FALSE;

        dbg(FLOODING_CHANNEL, "\"cost=%i\", TTL: %i, Src: %i, Dest: %i, Floodsrc: %i, Seq: %i, ", data->cost, header->TTL, myMsg->src, myMsg->dest, header->floodsrc, header->seq);
        
        data->cost++;
        if(call Flooding.flood(myMsg) == SUCCESS)
        {
            for(i = 0; i < MAX_ROUTING; i++)
            {
                if(table[i].dest == header->floodsrc)
                {
                    found = TRUE;
                    if(data->cost < table[i].cost)
                    {
                        table[i].toAlt = table[i].to;
                        table[i].costAlt = table[i].cost;

                        table[i].to = myMsg->src;
                        table[i].cost = data->cost;

                        updated = TRUE;
                    }
                    else if(data->cost == table[i].cost && myMsg->src == table[i].to){}
                    else if(table[i].to == table[i].toAlt){}
                    else if(data->cost < table[i].costAlt)
                    {
                        table[i].toAlt = myMsg->src;
                        table[i].costAlt = data->cost;

                        updated = TRUE;
                    }
                    
                    break;
                }
            }
            if(found == FALSE)
            {
                Route update;
                update.dest = header->floodsrc;
                update.to = myMsg->src;
                update.cost = data->cost;
                update.toAlt = 0;
                update.costAlt = INFINITY;
                table[tablePointer++] = update;
            }
        }
    }
    
    // command void Routing.receivedLinkStatePacket(pack* myMsg)
    // {
    //     floodingheader* header = (floodingheader*)&(myMsg->payload);
    //     uint8_t* payload = header->payload;
    //     bool finished = FALSE;
    //     bool found = FALSE;

    //     dbg(ROUTING_CHANNEL, "RECEIVED PACKET %i FROM %i\n", header->seq, header->floodsrc);

    //     for(i = 0; i < TABLE_CACHE_SIZE; i++)
    //     {
    //         if(cache[i].floodsrc == header->floodsrc)
    //         {
    //             if((cache[i].received + 1)*FLOODING_MAX_PAYLOAD_SIZE < sizeof(Route)*MAX_ROUTING)
    //             {
    //                 memcpy((&cache[i].table) + cache[i].received*FLOODING_MAX_PAYLOAD_SIZE, payload, FLOODING_MAX_PAYLOAD_SIZE);
    //                 cache[i].received++;
    //             }
    //             else
    //             {
    //                 memcpy((&cache[i].table) + cache[i].received*FLOODING_MAX_PAYLOAD_SIZE, payload, sizeof(Route)*MAX_ROUTING - cache[i].received*FLOODING_MAX_PAYLOAD_SIZE);
    //                 cache[i].received++;
    //                 finished = TRUE;
    //             }
    //             found = TRUE;
    //             break;
    //         }
    //     }
        
    //     if(found == FALSE)
    //     {
    //         TableCache update;
    //         update.floodsrc = header->floodsrc;
    //         update.received = 1;
    //         memcpy(&update.table, payload, FLOODING_MAX_PAYLOAD_SIZE);
    //         cache[cachePointer++] = update;

    //         dbg(ROUTING_CHANNEL, "NEW TABLE CACHE FOR %i!\n", header->floodsrc);
    //     }
        
    //     else if(finished == TRUE)
    //     {   
    //         // Printing for test purposes
    //         // memcpy(&table, &cache[i].table, sizeof(Route)*MAX_ROUTING);
    //         int j;
    //         int k;
    //         found = FALSE;

    //         for(j = 0; j < MAX_ROUTING; j++)
    //         {
    //             if(cache[i].table[j].dest != 0)
    //             {
    //                 for(k = 0; k < MAX_ROUTING; k++)
    //                 {
    //                     if(cache[i].table[j].dest == table[k].dest)
    //                     {
    //                         table[k] = cache[i].table[j];
    //                         table[k].to = myMsg->src;
    //                         break;
    //                     }
    //                 }
    //             }
    //         }

    //         call Routing.printLinkState();
            
    //         // After processing payload,
    //         // Parse and send the data
    //         for(i = 0; i < sizeof(Route)*MAX_ROUTING - FLOODING_MAX_PAYLOAD_SIZE; i = i + FLOODING_MAX_PAYLOAD_SIZE)
    //         {
    //             memcpy(&payload, &table + i, FLOODING_MAX_PAYLOAD_SIZE);
    //             // myMsg->src = TOS_NODE_ID;
    //             call Flooding.flood(myMsg);
    //         }
    //         memcpy(&payload, &table + i, sizeof(Route)*MAX_ROUTING - i);
    //         call Flooding.flood(myMsg);

    //     }

        
    // }

    command void Routing.forward(uint16_t destination, uint8_t* payload)
    {
        dbg(ROUTING_CHANNEL, "Forwarding\n");
    }

    command void Routing.printLinkState()
    {
        dbg(ROUTING_CHANNEL, "DEST  TO  COST  ALT  ALTCOST\n");
        for(i = 0; i < MAX_ROUTING; i++)
        {
            if(table[i].dest != 0)
            dbg_clear(ROUTING_CHANNEL, "                               %i    %i    %i    %i    %i\n", table[i].dest, table[i].to, table[i].cost, table[i].toAlt, table[i].costAlt);
        }
    }
}